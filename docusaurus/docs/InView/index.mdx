---
sidebar_position: 500
toc_min_heading_level: 2
toc_max_heading_level: 6
---

# InView

InView is a visibility detection utility that leverages the `IntersectionObserver API` to monitor when elements enter or leave the viewport. 

It provides customizable options for triggering events, delaying visibility changes, and dynamically adding CSS classes to elements based on their visibility state.



## Basic Example

<iframe 
  height="600"
  style={{
    width: '100%'
  }} 
  scrolling="no" 
  title="Vevet Example"
  src="https://codepen.io/anton-bobrov/embed/EaaYRmX?default-tab=result"
  frameborder="no"
  loading="lazy"
  allowtransparency="true"
  allowfullscreen="true"
>
  See the Pen <a href="https://codepen.io/anton-bobrov/pen/EaaYRmX">Vevet Example</a> by Anton Bobrov.
</iframe>



## More demos

To explore more demos, click [here](./demos).



## Initialization

InView is easy to initialize:

```html
<h1 id="observable-element">Hello, World!</h1>
```

```js
import { InView } from "vevet";

const observer = new InView();

observer.on('in', ({ element }) => {
  console.log('do something with', element);
});

observer.addElement(
  document.getElementById('observable-element')
);
```

InView can add a custom class to an element when it enters the viewport, and remove the class when it leaves the viewport.

For such a behavior, use `data-in-view-class`:

```html
<h1 class="observable-element" data-in-view-class="fadeInUp">InView</h1>
```

:::caution Class Behavior
The class from `data-in-view-class` is added when the element enters the viewport and removed once it leaves it  
(if `hasOut: true`).  
This allows creating fully CSS-driven scroll animations without JavaScript transitions.
:::

:::caution Zero-Size Elements
InView cannot detect visibility of elements with `display: none` or zero height/width.  
Ensure the element has a measurable size before adding it to the observer.
:::

Stop observing the element

```js
observer.removeElement(yourElement);
```

Destroy InView

```js
observer.destroy();
```



## Best Practices

- Prefer adding a **single InView instance** and registering multiple elements instead of creating many observers.
- Avoid observing extremely large numbers of elements — group content into sections when possible.
- Use `hasOut: false` if you only need one-time triggers — this improves performance and reduces callback spam.