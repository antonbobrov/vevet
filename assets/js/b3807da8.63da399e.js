"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[440],{4311:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>a,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"components/ScrollProgress/index","title":"ScrollProgress","description":"todo: examples","source":"@site/docs/components/ScrollProgress/index.mdx","sourceDirName":"components/ScrollProgress","slug":"/components/ScrollProgress/","permalink":"/vevet/docs/components/ScrollProgress/","draft":false,"unlisted":false,"editUrl":"https://github.com/antonbobrov/vevet/tree/master/docusaurus/docs/components/ScrollProgress/index.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Raf","permalink":"/vevet/docs/components/Raf/"},"next":{"title":"Scrollbar","permalink":"/vevet/docs/components/Scrollbar/"}}');var o=n(4848),t=n(8453);const l={},i="ScrollProgress",c={},d=[{value:"Props",id:"props",level:2},{value:"Static Props",id:"static-props",level:3},{value:"Accessors",id:"accessors",level:2},{value:"inProgress",id:"inprogress",level:3},{value:"isVisible",id:"isvisible",level:3},{value:"moveProgress",id:"moveprogress",level:3},{value:"outProgress",id:"outprogress",level:3},{value:"progress",id:"progress",level:3},{value:"rootBounds",id:"rootbounds",level:3},{value:"section",id:"section",level:3},{value:"sectionBounds",id:"sectionbounds",level:3},{value:"Methods",id:"methods",level:2},{value:"getProgress",id:"getprogress",level:3},{value:"Parameters",id:"parameters",level:4},{value:"update",id:"update",level:3},{value:"Callbacks",id:"callbacks",level:2},{value:"update",id:"update-1",level:3}];function h(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"scrollprogress",children:"ScrollProgress"})}),"\n",(0,o.jsx)(s.p,{children:"todo: examples"}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"ScrollProgress"})," is a component that tracks the scroll progress of a specified section element."]}),"\n",(0,o.jsx)(s.p,{children:"This component can be used for creating scroll-based animations such as parallax effects."}),"\n",(0,o.jsx)(s.h2,{id:"props",children:"Props"}),"\n",(0,o.jsx)(s.h3,{id:"static-props",children:"Static Props"}),"\n",(0,o.jsx)(s.p,{children:"Static properties are set during initialization and cannot be modified later."}),"\n",(0,o.jsxs)("table",{children:[(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{children:"Name"}),(0,o.jsx)("th",{children:"Description"}),(0,o.jsx)("th",{children:"Type"}),(0,o.jsx)("th",{children:"Default Value"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"section"}),(0,o.jsx)("td",{children:"The element whose scroll progress is tracked."}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"Element"})}),(0,o.jsx)("td",{})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"root"}),(0,o.jsxs)("td",{children:["The root element used as a reference for scroll progress calculation. Usually it is the scroll container. If ",(0,o.jsx)(s.code,{children:"null"}),", the viewport is used as the reference."]}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"Element | null"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"null"})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"optimized"}),(0,o.jsxs)("td",{children:["If ",(0,o.jsx)(s.code,{children:"true"}),", progress is calculated only while the section is within the viewport or the root element. Improves performance by avoiding unnecessary calculations."]}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"boolean"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"true"})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"useSvh"}),(0,o.jsxs)("td",{children:["If ",(0,o.jsx)(s.code,{children:"true"}),", the scroll progress is calculated based on the small viewport height (svh in css) instead of the current viewport height (vh in css)."]}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"boolean"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{children:"false"})})]})]}),"\n",(0,o.jsx)(s.h2,{id:"accessors",children:"Accessors"}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsxs)(s.p,{children:["All ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.a,{href:"/docs/base/Module/#accessors",children:"Module's accessors"})})," are available in this class."]})}),"\n",(0,o.jsx)(s.h3,{id:"inprogress",children:"inProgress"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ x: number; y: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"Calculates the progress of the section entering the root element."}),"\n",(0,o.jsx)(s.h3,{id:"isvisible",children:"isVisible"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"boolean"})]}),"\n",(0,o.jsx)(s.p,{children:"Indicates whether the section is currently visible within the viewport or root element."}),"\n",(0,o.jsx)(s.h3,{id:"moveprogress",children:"moveProgress"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ x: number; y: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"Calculates the progress of the section's movement within the root element."}),"\n",(0,o.jsx)(s.h3,{id:"outprogress",children:"outProgress"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ x: number; y: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"Calculates the progress of the section leaving the root element."}),"\n",(0,o.jsx)(s.h3,{id:"progress",children:"progress"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ x: number; y: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"Calculates the global scroll progress of the section relative to the root element."}),"\n",(0,o.jsx)(s.h3,{id:"rootbounds",children:"rootBounds"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ height: number; left: number; top: number; width: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"The bounds of the root element used for scroll calculations."}),"\n",(0,o.jsx)(s.h3,{id:"section",children:"section"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"Element"})]}),"\n",(0,o.jsx)(s.p,{children:"Returns the section element being tracked for scroll progress."}),"\n",(0,o.jsx)(s.h3,{id:"sectionbounds",children:"sectionBounds"}),"\n",(0,o.jsxs)(s.p,{children:["Type: ",(0,o.jsx)(s.code,{children:"{ height: number; left: number; top: number; width: number }"})]}),"\n",(0,o.jsx)(s.p,{children:"The bounds of the section element relative to the root element."}),"\n",(0,o.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsxs)(s.p,{children:["All ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.a,{href:"/docs/base/Module/#methods",children:"Module's methods"})})," are available in this class."]})}),"\n",(0,o.jsx)(s.h3,{id:"getprogress",children:"getProgress"}),"\n",(0,o.jsx)(s.p,{children:"Calculates the section scroll progress relative to the root element."}),"\n",(0,o.jsx)(s.p,{children:"The function takes top or left corner of the section as the reference point."}),"\n",(0,o.jsx)(s.h4,{id:"parameters",children:"Parameters"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"topThreshold: number"}),"\nTop threshold of the section position."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"rightThreshold: number"}),"\nRight threshold of the section position."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"bottomThreshold: number"}),"\nBottom threshold of the section position."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"leftThreshold: number"}),"\nLeft threshold of the section position."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ts",children:"const progress = instance.getProgress(0, vevet.width, vevet.height / 2, 0);\n\n// `progress.y` is `0` when the top corner of the section is at the beginning of the viewport or root element\n// `progress.y` is `1` when the top corner of the section is at the center of the viewport or root element\n"})}),"\n",(0,o.jsx)(s.h3,{id:"update",children:"update"}),"\n",(0,o.jsx)(s.p,{children:"Updates the section and root bounds, and emits an update callback."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ts",children:"instance.update();\n"})}),"\n",(0,o.jsx)(s.h2,{id:"callbacks",children:"Callbacks"}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsxs)(s.p,{children:["All ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.a,{href:"/docs/base/Module/#callbacks",children:"Module's callbacks"})})," are available in this class."]})}),"\n",(0,o.jsx)(s.h3,{id:"update-1",children:"update"}),"\n",(0,o.jsx)(s.p,{children:"Triggered on each scroll progress update."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ts",children:"const destruct = instance.on('update', () => console.log('update'));\n\n// Cancel the callback\ndestruct();\n"})})]})}function a(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>i});var r=n(6540);const o={},t=r.createContext(o);function l(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);